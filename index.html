<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <title>Clicker Game</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            display: flex;
            height: 100vh;
            background-color: #FFD9AD;
        }

        /* Left Sidebar */
        #left-sidebar {
            width: 25%;
            height: 100%;
            padding: 10px;
            display: flex;
            flex-direction: column;
            justify-content: flex-start;
            border: 4px solid black;
            box-sizing: border-box;
            gap: 20px;
        }

        #left-sidebar h1 {
            margin: 0;
            padding: 10px;
            border: 4px solid black;
            box-sizing: border-box;
        }

        #left-sidebar h2 {
            margin: 0;
            padding: 10px;
            border: 4px solid black;
            box-sizing: border-box;
            font-size: 18px;
        }

        #left-sidebar .buttons-container {
            display: flex;
            flex-direction: column;
            gap: 10px;
        }

        .section-btn {
            width: 100%;
            padding: 10px;
            border: 2px solid black;
            background-color: #FFBC70;
            cursor: pointer;
            box-sizing: border-box;
            text-align: center;
            position: relative;
            box-shadow: #604D53 4px 4px 0px
        }

        .tab-btn, .item-btn {
            padding: 10px;
            border: 2px solid black;
            background-color: #FFBC70;
            cursor: pointer;
            box-sizing: border-box;
            text-align: center;
            position: relative;
            width: fit-content;
            white-space: nowrap;
            box-shadow: #604D53 4px 4px 0px
        }

        .tab-btn.locked, .item-btn.locked, .section-btn.locked {
            pointer-events: none;
            opacity: 0.5;
        }

        .tab-btn:hover .modal, .item-btn:hover .modal, .section-btn:hover .modal {
            display: block;
        }

        /* Modal Style */
        .modal {
            display: none;
            position: absolute;
            top: 100%;
            left: 0;
            width: max-content;
            padding: 10px;
            margin-top: 10px;
            border: 1px solid black;
            background-color: white;
            box-sizing: border-box;
            z-index: 1;
        }

        /* Right Side */
        #right-content {
            flex-grow: 1;
            display: flex;
            flex-direction: column;
            padding: 10px;
            border: 1px solid black;
            box-sizing: border-box;
        }

        #tabs-container {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            padding-bottom: 10px;
        }

        #items-container {
            display: flex;
            flex-direction: column;
            gap: 10px;
        }

        #number-display {
            font-size: 24px;
            margin-bottom: 20px;
        }
    </style>
</head>
<body>

    <div id="left-sidebar">
        <h1 id="number-display">ℕ: 20</h1>
        <h2 id="number-per-second">ℕ per second: 0</h2>
        <div class="buttons-container" id="sections-container"></div>
    </div>

    <div id="right-content">
        <div id="tabs-container"></div>
        <div id="items-container"></div>
    </div>

    <script>
        // Game State
        let gameState = {
            numbers: 20,
            numbersPerSecond: 0,
            sections: {},
            tabs: {},
            items: {},
            unlocked: {
                sections: {},
                tabs: {},
                items: {}
            },
            activeSection: null,  // Track the currently active section
            activeTab: null       // Track the currently active tab
        };

    
        let gameConfig = {};

        async function loadGameConfig() {
            try {
                const response = await fetch('gameConfig.json');
                if (!response.ok) {
                    throw new Error('Network response was not ok');
                }
                const data = await response.json();
                gameConfig = data;
                processConfigFunctions(); // Convert string functions to actual functions
                renderGame();
            } catch (error) {
                console.error('There has been a problem with your fetch operation:', error);
            }
        }

        function processConfigFunctions() {
            gameConfig.sections.forEach(section => {
                section.tabs.forEach(tab => {
                    tab.items.forEach(item => {
                        item.priceFunction = eval(`(${item.priceFunction})`);
                        item.nPerSecondFunction = eval(`(${item.nPerSecondFunction})`);
                    });
                });
            });
        }







        // Centralized Render Function
        function renderGame() {
            console.log("Rendering game...");

            // Clear existing content
            document.getElementById('sections-container').innerHTML = '';
            document.getElementById('tabs-container').innerHTML = '';
            document.getElementById('items-container').innerHTML = '';

            // Render sections
            gameConfig.sections.forEach(section => {
                if (gameState.numbers >= section.shownFrom || gameState.unlocked.sections[section.id]) {
                    gameState.unlocked.sections[section.id] = true;

                    const sectionButton = document.createElement('div');
                    sectionButton.className = 'section-btn';
                    sectionButton.textContent = section.name;
                    sectionButton.onclick = () => {
                        gameState.activeSection = section.id;
                        gameState.activeTab = null;  // Reset activeTab when changing sections
                        renderTabs(section.id);
                    };

                    const sectionModal = document.createElement('div');
                    sectionModal.className = 'modal';
                    sectionModal.textContent = section.modalMessage;
                    sectionButton.appendChild(sectionModal);

                    document.getElementById('sections-container').appendChild(sectionButton);
                }
            });

            // Render the currently active section's tabs and items
            if (gameState.activeSection) {
                renderTabs(gameState.activeSection);
            } else {
                const firstSection = gameConfig.sections.find(section => gameState.unlocked.sections[section.id]);
                if (firstSection) renderTabs(firstSection.id);
            }
        }

        // Render Tabs and Items for a Given Section
        function renderTabs(sectionId) {
            const section = gameConfig.sections.find(sec => sec.id === sectionId);
            if (!section) return;

            document.getElementById('tabs-container').innerHTML = '';
            document.getElementById('items-container').innerHTML = ''; // Clear items when changing tabs

            section.tabs.forEach(tab => {
                if (gameState.numbers >= tab.shownFrom || gameState.unlocked.tabs[tab.id]) {
                    gameState.unlocked.tabs[tab.id] = true;

                    const tabButton = document.createElement('div');
                    tabButton.className = 'tab-btn';
                    tabButton.textContent = tab.name;
                    tabButton.onclick = () => {
                        gameState.activeTab = tab.id;
                        renderItems(tab.id);
                    };

                    const tabModal = document.createElement('div');
                    tabModal.className = 'modal';
                    tabModal.textContent = tab.modalMessage;
                    tabButton.appendChild(tabModal);

                    document.getElementById('tabs-container').appendChild(tabButton);
                }
            });

            // Automatically show items for the currently active tab or the first available tab
            if (gameState.activeTab) {
                renderItems(gameState.activeTab);
            } else {
                const firstTab = section.tabs.find(tab => gameState.unlocked.tabs[tab.id]);
                if (firstTab) {
                    gameState.activeTab = firstTab.id;
                    renderItems(firstTab.id);
                }
            }
        }

        // Render Items for a Given Tab
        function renderItems(tabId) {
            const tab = gameConfig.sections.flatMap(section => section.tabs).find(t => t.id === tabId);
            if (!tab) return;

            document.getElementById('items-container').innerHTML = '';

            tab.items.forEach(item => {
                // Ensure that the item state is initialized
                if (!gameState.items[item.id]) {
                    gameState.items[item.id] = { amountOwned: 0, ...item };
                }

                if (gameState.numbers >= item.shownFrom || gameState.unlocked.items[item.id]) {
                    gameState.unlocked.items[item.id] = true;

                    const itemButton = document.createElement('div');
                    itemButton.className = 'item-btn';
                    const newPrice = item.priceFunction(gameState.items[item.id].amountOwned);
                    itemButton.textContent = `${item.name} = ${format(gameState.items[item.id].amountOwned)} - Price: ${format(newPrice)} ℕ`;

                    itemButton.onclick = () => buyItem(item.id);

                    const itemModal = document.createElement('div');
                    itemModal.className = 'modal';
                    itemModal.textContent = item.modalMessage;
                    itemButton.appendChild(itemModal);

                    document.getElementById('items-container').appendChild(itemButton);

                    // Store a reference to the button in the game state
                    gameState.items[item.id].buttonRef = itemButton;
                }
            });

            MathJax.typeset()
        }

        // Buy Item
        function buyItem(itemId) {
            const item = gameState.items[itemId];
            if (!item) return;

            const price = item.priceFunction(item.amountOwned);
            if (gameState.numbers >= price) {
                gameState.numbers -= price;
                item.amountOwned += 1;
                updateNumbersPerSecond();
                updateNumberDisplay();  // Update display immediately after purchase

                // Update the button text immediately
                const newPrice = item.priceFunction(item.amountOwned);
                item.buttonRef.textContent = `${item.name} = ${format(gameState.items[item.id].amountOwned)} - Price:  ${format(newPrice)} ℕ`;
            }

            MathJax.typeset();

        }

        // Update N per second calculations based on owned items
        function updateNumbersPerSecond() {
            gameState.numbersPerSecond = gameConfig.sections.flatMap(section => section.tabs)
                .flatMap(tab => tab.items)
                .reduce((total, item) => total + item.nPerSecondFunction(gameState.items[item.id]?.amountOwned || 0), 0);
        }

        // Update Display
        function updateNumberDisplay() {
            document.getElementById('number-display').textContent = `ℕ: ${format(gameState.numbers)}`;
            document.getElementById('number-per-second').textContent = `ℕ per second: ${format(gameState.numbersPerSecond)}`;
        }

        // Increment numbers per second
        function incrementNumbers() {
            gameState.numbers += gameState.numbersPerSecond;
            updateNumberDisplay();
            renderGame(); // Re-render game elements after incrementing N
        }

        // Format numbers with spaces: turns 46552 into 46 552.
        function format(number) {
            return number.toString().replace(/\B(?=(\d{3})+(?!\d))/g, ' ');
        }


        // Save Game State to Local Storage
        function saveGameState() {
            const saveData = {
                numbers: gameState.numbers,
                items: Object.keys(gameState.items).reduce((acc, itemId) => {
                    acc[itemId] = {
                        amountOwned: gameState.items[itemId].amountOwned
                    };
                    return acc;
                }, {})
            };
            localStorage.setItem('clickerGameSave', JSON.stringify(saveData));
            console.log('Game saved.');
        }

        // Load Game State from Local Storage
        function loadGameState() {
            const savedData = localStorage.getItem('clickerGameSave');
            if (savedData) {
                const parsedData = JSON.parse(savedData);
                gameState.numbers = parsedData.numbers || 0;

                if (parsedData.items) {
                    Object.keys(parsedData.items).forEach(itemId => {
                        if (gameState.items[itemId]) {
                            console.log(parsedData.items[itemId].amountOwned);
                            gameState.items[itemId].amountOwned = parsedData.items[itemId].amountOwned;
                        }
                    });
                }

                updateNumbersPerSecond(); // Recalculate numbers per second based on loaded items
                console.log('Game loaded.');
            }
        }

        // Initialize the game on window load
        window.onload = async function() {
            await loadGameConfig(); // Load the game config before rendering
            renderGame();
            loadGameState(); // Load the game state before rendering
            updateNumbersPerSecond();
            updateNumberDisplay();
            setInterval(incrementNumbers, 1000);
            setInterval(saveGameState, 60000); // Save the game state every minute
        };



        // Save game state when the user leaves the page
        window.onbeforeunload = function() {
            saveGameState();
        };

    </script>
</body>
</html>
